#!/usr/bin/perl

###
###	⛈	optimistiCli: TVRain.ru command line client that gives legitimate paying users command line access to the video archive.
###

use utf8;
use strict;
use open IO  => ":encoding(utf8)";


### TODOs:
###  1. Add config and command line options to set merger
###  2. Use curl if there's no wget
###  3. Command to download latest full program by name
###  4. Use OS-indepenadant path handling
###  5. Implement 2-level verbosity with no operational output on base level.
###  6. Add external executable paths to options and config
###  7. Process a list of video ids, either from command line of from a file
###  8. Add option to output playlist to STDOUT (-o -)

our $usage = 'Usage:
  get_tvrain [-h|--long-help] [-c <merge|save|pls|info|programs|articles>]
  [-q <fhd|hd|sd|lo>] [-d <output dir>] [-o <output file name>]
  [-t <temp dir>] [-i] [-C <config file>] [-I <max items>] [-v] [-F] [-S]
  <Show ID | Page with video URL | Program ID>

TVRain.ru show archive command line client. Legitimate paying users only!

To download a show in current directory run:
  get_tvrain http://tvrain.ru/teleshow/reportazh/the_rain_is_falling-123456/

To get detailed options description run:
  get_tvrain --long-help
';

our $long_help = $usage . '
Options:
  -h Show usage and exit
  -c Command, instructs get_tvrain what to do
       Downloading videos:
       m|merge    - downloads all parts of the video and merges them into one
                    matroska file, requires temp directory for downloaded parts,
                    this is the default command
       s|save     - saves each part of the video as is
       Retreiving information (no videos downloaded):
       p|pls      - saves a playlist with video URLs
       i|info     - prints out video informaton
       r|programs - saves full list of available programs as a text file
       a|articles - saves list of articles of the program specified by the 
                    program ID as a text file; see -I for max number of items
  -q Video quality selector, available options are:
       f|fhd - full HD aka 1080p
       h|hd  - high definition aka 720p (default)
       s|sd  - standard definition aka 480p
       l|lo  - low bitrate aka 360p
  -d Write output file(s) to the specified directory, defaults to current
     directory
  -o Set output file(s) name, if omitted the article / feature name is used
     to compose the file name(s); overrides -d and -i
  -t Use specified directory to temporarily store downloaded video parts for
     the "merge" command, if omitted looks up temp_dir in the configuration
     file, which defaults to the current directory
  -i Use show ID for the file(s) name
  -C Use specified configuration file instead of the default one
  -I Max number of items retrieved from the server; applies to the articles
     command; if ommited defaults to a reasonable number
  -v Verbose output, prints a lot of debugging stuff to STDERR
  -F Force first run, resets all options, see below
  -S Simulate, do not actualy download anything

Examples:
  Download a show by URL, if video consists of several parts merge them
  together. Use /tmp to store temporary files.
  get_tvrain -t /tmp http://tvrain.ru/teleshow/reportazh/falling_rain-123456/

  Download a show known by its ID to the Desktop. Select low bitrate to
  preserve the bandwidth. If there are several video files save them
  separately. Name files using show ID.
  get_tvrain -d ~/Desktop -q lo -c save -i 123456

  Create a custom-named playlist of the standard definition videos. If a
  playlist by the same name already exists overwrite it.
  get_tvrain -q sd -o /mnt/autoplay/tvrain.pls -c pls -y 123456

Requirements:
  A few perl modules off CPAN are required. If they are missing the program
  will let you know which modules it lacks and suggest a way to install them.
  Also wget is used to download stuff and either mkvmerge or ffmpeg for
  joining video fragments.

Configuration file:
  The configuration file is .get_tvrain.conf in your home directory, This file
  is created automatically during the first run. Use -C option to run with
  alternative configuration file. File format is name=value, no whitespaces
  around the "=", no comments after the value are allowed. Encoding is UTF-8.
  Noteworthy options:
    device_uid
      Client-side hardware unique identifier / serial number. In fact this
      value is randomly generated during the first run.
    auth
      Authentication key. This value is obtained from the server when the
      client is linked to TVRain.ru user account as a part of the first run
      routine.
    temp_dir
      The directory to temporarily store downloaded video parts for the
      "merge" command. Please make sure the directory is on a reasonably fast
      storage device (ie the use of thumb drives and flash cards is
      discouraged) and that it has enough free space (4Gb would do). If not
      set the current directory or the value passed with the -t option is
      used.

First run:
  When run for the first time the "first run routine" is invoked to configure
  the application. It does as follows:
    1. configuration file is created
    2. unique identifier is randomly generated
    3. client is linked to the TVRain.ru user account
    4. temporary directory is set
  To clear all the settings the first run routine can be re-run manually
  by specifying the -F option or just by deleting the configuration file.

Linking:
  In order to gain access to the TVRain.ru show archive the client software
  should be "linked" to an active paid user account. Linking happens during
  the first run and requires internet access and user interaction.

';

our $linking_hint = 'Q What to do next?
A 1. Open http://tvrain.ru/profile/ in a brwoser
  2. Log into an account
  3. Browse to "Profile" → "Devices"
  4. Enter the linking code (see above) and perss "Link"
  5. Wait until get_tvrain resumes\n

';

our $relink_hint = '

You might want to re-link the client by specifying the -F option.
For more details please run:
get_tvran --long-help
';


### Constants

our $REQUIRED_MODULES = [
	'File::HomeDir',
	'Config::Tiny',
	'HTTP::Headers',
	'HTTP::Request',
	'CGI::Utils',
	'LWP::UserAgent',
	'LWP::Protocol::https',
	'Mozilla::CA',
	'JSON',
	'MIME::Base64',
	'Getopt::Long',
	'IO::Scalar',
	'Cwd',
	'IPC::Run3',
	'Term::ReadKey',
];
our $CONFIG_FILE_NAME = '.get_tvrain.conf';
our $DEVICE_NAME = 'optimistiCli';
our $API_URL_BASE = 'https://api.tvrain.ru/api_v2';
our $SITE_URL_BASE = 'https://tvrain.ru';
our $API_CONSUMER_KEY = 'a908545f-80af-4f99-8dac-fb012cec';
our $API_VERSION = '2.13';
our $LINK_POLL_TIMEOUT_SEC=15;
our $COMMAND_MERGE = 'merge';
our $COMMAND_SAVE = 'save';
our $COMMAND_PLAYLIST = 'pls';
our $COMMAND_INFO = 'info';
our $COMMAND_PROGRAMS_LIST = 'programs';
our $COMMAND_PROGRAM_ARTICLES = 'articles';
our $COMMAND_QUIT = 'quit';
our $COMMAND_INTERACTIVE = 'interactive';
our $QUALITY_FH = 'fh';
our $QUALITY_HD = 'hd';
our $QUALITY_SD = 'sd';
our $QUALITY_LO = 'lo';
our $MAX_FILE_NAME_LENGTH = 64;
our $MAX_PROGRAM_NAME_LENGTH = 24;
our $MIN_NAME_PART_LENGTH = 8;
our $NAME_PARTS_CONNECTOR = ' - ';
our @WGET_ERRORS = (
	'No problems occurred',
	'Generic error code',
	'Parse error—for instance, when parsing command-line options, the ".wgetrc" or ".netrc"',
	'File I/O error',
	'Network failure',
	'SSL verification failure',
	'Username/password authentication failure',
	'Protocol errors',
	'Server issued an error response',
);
our $MERGE_WITH_MKVMERGE = 'mkvmerge';
our $MERGE_WITH_FFMPEG = 'ffmpeg';
our $ITEMS_PER_REQUEST_PAGE = 10;
our $PROGRAMS_FILE_NAME = 'programs.txt';
our $MAX_REQUEST_PAGES = 5;
our $COMMAND_PROMPT_DEFAULT_MARKER = '(default) ';
our $DEFAULT_WAIT_FOR_INPUT = 60;
our $COMMAND_PROMPT_TIME_STEP = .05;
our $COMMAND_PROMPT_CHAR_TO_COMMAND = {
	'm'	=> $COMMAND_MERGE,
	's'	=> $COMMAND_SAVE,
	'p'	=> $COMMAND_PLAYLIST,
	'q'	=> $COMMAND_QUIT,
};
our $VIDEO_CANT_BE_SO_SMALL = 1 * 1024 * 1024;
our $SECONDS_BETWEEN_SAME_VIDEO_RETRIES = 12;
our $SAME_VIDEO_MAX_RETRIES = 12;


### Globals

our $options;	# Command line options
our $config;	# Config file values
our $session;	# Session-wide values

# TODO: Move objects into session
our $cgi_utils;
our $user_agent;
our $json;


### Functions

sub dumpit;
sub MIME::Base64::encode_base64;

sub set_binmode {
	binmode STDOUT, ":utf8";
	binmode STDERR, ":utf8";
}

sub boolean_to_string {
	return int $_[0]
		? 'Yes'
		: 'No';
}

sub ceiling {
	my $f = shift;
	my $i = int $f;

	return $f > $i
		? 1 + $i
		: $i;
}

sub dumpit {
	my $workload = shift;
	my $name = shift;
	my $depth = shift;

	$depth ||= 0;

	my $buffer = '';

	my $type = ref($workload);

	if ($type eq 'ARRAY') {
		$buffer .= '  ' x $depth;
		$buffer .= $name . ' → ' if defined $name;
		$buffer .= "[\n";

		for (my $i = 0 ; $i < scalar @$workload; $i++) {
			$buffer .= dumpit $workload->[$i], $i, $depth + 1;
		}

		$buffer .= '  ' x $depth;
		$buffer .= "]\n";
	} elsif ($type eq 'HASH') {
		$buffer .= '  ' x $depth;
		$buffer .= $name . ' → ' if defined $name;
		$buffer .= "{\n";

		foreach my $key (sort keys %$workload) {
			$buffer .= dumpit $workload->{$key}, $key, $depth + 1;
		}

		$buffer .= '  ' x $depth;
		$buffer .= "}\n";
	} else {
		$buffer .= '  ' x $depth;
		$buffer .= $name . ' → ' if defined $name;
		$buffer .= "$workload\n";
	}

	return $buffer;
}

sub debug {
	my $title = shift;
	my $text = shift;

	$title = uc $title;
	print STDERR "============ $title START ============\n$text\n============= $title END =============\n\n";
}

sub brag_and_exit {
	my $error_message = shift;
	my $exit_code = shift;

	if ($error_message) {
		chomp $error_message;
		$error_message =~ s/^/  /gms;
		$error_message = "Error:\n$error_message\n\n";
		$exit_code = 1 unless $exit_code;
	}

	print $error_message, $usage, "\n";
	exit $exit_code;
}

# Runs before proper options interpreter and tries to establish if user wants to print debug messages
sub guess_if_verbose {
	for (my $i = 0; $i < scalar @ARGV; $i++) {
		next unless $ARGV[$i] =~ /^-.*v/;

		$options->{'verbose'} = 1;
		return;
	}
}

sub cook_missing_modules_error_message {
	my $missing_modules = shift;

	return unless scalar @$missing_modules;

	my $pre_module = "sudo perl -MCPAN -e 'install +";
	my $post_module = "'";

	my $missing_modules_error_matrix = sprintf 'One or more required perl modules are missing. On many sane systems (not on
cygwin) They can be installed off CPAN by running something like this:
>=== CODE ===<
%s%%s%s
>=== CODE ===<',
	$pre_module, $post_module;

	sprintf $missing_modules_error_matrix, join "$post_module\n$pre_module", @$missing_modules;
}

sub check_modules {
	my $installed_modules = [];
	my $missing_modules = [];

	foreach my $module (@$REQUIRED_MODULES ) {
		my $stack = eval("require $module;")
			? $installed_modules
			: $missing_modules;

		push @$stack, $module;
	}

	debug 'installed modules', join "\n", @$installed_modules if $options->{'verbose'};
	debug 'missing modules', join "\n", @$missing_modules if $options->{'verbose'};

	brag_and_exit cook_missing_modules_error_message $missing_modules if scalar @$missing_modules;
}

sub millisec_to_human_readeble {
	$_ = shift;

	my $millisec = $_ % 1000;
	$_ = int $_ / 1000;

	my $seconds = $_ % 60;
	$_ = int $_ / 60;

	my $minutes = $_ % 60;
	$_ = int $_ / 60;

	my $hours = $_;

	sprintf '%02i:%02i:%02i.%03i', $hours, $minutes, $seconds, $millisec;
}

sub init {
	Getopt::Long::Configure ('no_ignore_case', 'require_order', 'bundling');

	$cgi_utils = CGI::Utils->new;
	$user_agent = LWP::UserAgent->new;
	$json = JSON->new;

	$session->{'command_stack'} = [];
}

sub set_options_defaults {
	$options = {
		'help'						=> 0,
		'long_help'				=> 0,
		'verbose'					=> 0,
		'simulate'				=> 0,
		'first_run'				=> 0,
		'command'					=> $COMMAND_INTERACTIVE,
		'quality'					=> $QUALITY_HD,
		'output_dir'			=> undef,
		'output_file'			=> undef,
		'temp_dir'				=> undef,
		'id'							=> 0,
		'yes_all'					=> 0,
		'config'					=> undef,
		'max_items'				=> 0,
		'wait_for_input'	=> $DEFAULT_WAIT_FOR_INPUT,
	};
}

# Creates an empty file and immediately deletes it
sub get_file_creation_error {
	my $file_path = shift;
	my $description = shift;

	return "$description already exists '$file_path" if -e $file_path;

	open FH, "> $file_path" or return "$description can not be written to '$file_path', $!";
	close FH;

	unlink $file_path or die "Failed to delete touched file '$file_path'";

	return undef;
}

sub get_dir_wrieable_error {
	my $dir_path = shift;
	my $description = shift;

	return "$description '$dir_path' does not exist" unless -e $dir_path;

	return "$description '$dir_path' is not a directory" unless -d $dir_path;

	return "$description '$dir_path' can not be written to" unless -w $dir_path;

	undef;
}

sub check_if_dir_is_writeable {
	my $dir_path = shift;
	my $description = shift;

	return unless defined $dir_path;

	my $dir_wrieable_error = get_dir_wrieable_error $dir_path, $description;

	brag_and_exit $dir_wrieable_error if defined $dir_wrieable_error;

	$dir_path;
}

sub check_option_command {
	# Command should be set, otherwise there is an error

	$_ = $options->{'command'};

	$options->{'command'} =
		/^(?:m|merge|mkv|join|matroska)$/i ? $COMMAND_MERGE :
		/^(?:s|save|download|dl|asis|mp4|dump)$/i ? $COMMAND_SAVE :
		/^(?:p|pls|playlist|pls|play.?list|m3u|m3u8)$/i ? $COMMAND_PLAYLIST :
		/^(?:i|info|information|inf)$/i ? $COMMAND_INFO :
		/^(?:r|prog|programs)$/i ? $COMMAND_PROGRAMS_LIST :
		/^(?:a|articles)$/i ? $COMMAND_PROGRAM_ARTICLES :
		/^(?:n|interactive)$/i ? $COMMAND_INTERACTIVE :
		brag_and_exit "Unknown command $_";

	debug 'command', $options->{'command'} if $options->{'verbose'};
}

sub check_option_quality {
	# Quality should be set, otherwise there is an error
	$_ = $options->{'quality'};

	$options->{'quality'} =
		/^(?:if|fh|fhd|full.*|1080|1080p)$/i ? $QUALITY_FH :
		/^(?:ih|hd|hq|high|hi|720|720p)$/i ? $QUALITY_HD :
		/^(?:is|sd|sq|stand.*|std|480|480p)$/i ? $QUALITY_SD :
		/^(?:il|lo|ld|lq|lo|low|360|360p)$/i ? $QUALITY_LO :
		brag_and_exit "Unknown quality $_";

	debug 'quality', $options->{'quality'} if $options->{'verbose'};
}

sub check_option_output_dir {
	return unless defined $options->{'output_dir'};

	$options->{'output_dir'} = check_if_dir_is_writeable $options->{'output_dir'}, 'Output directory';

	debug 'output dir', $options->{'output_dir'} if $options->{'verbose'};
}

sub check_if_file_is_writeable {
	my $file_path = shift;
	my $description = shift;

	return unless defined $file_path;

	if (-e $file_path) {
		# File exist: check if it is a proper file and if it can be overwritten

		brag_and_exit "$description is not a file '$file_path'" unless -f $file_path;

		# TODO: Simlinks get through the -f above. Decide if they need some special tratment.

		brag_and_exit "$description can not be overwritten '$file_path'" unless -w $file_path;
	} else {
		# File does not exist: check if it can be created and written to

		my $file_creation_error = get_file_creation_error $file_path, $description;
		brag_and_exit $file_creation_error if defined $file_creation_error;
	}

	$file_path;
}

sub check_option_output_file {
	return unless defined $options->{'output_file'};

	$options->{'output_file'} = check_if_file_is_writeable $options->{'output_file'}, 'Output file';

	debug 'output file', $options->{'output_file'} if $options->{'verbose'};
}

sub check_option_temp_dir {
	return unless defined $options->{'temp_dir'};

	$options->{'temp_dir'} = check_if_dir_is_writeable $options->{'temp_dir'}, 'Temporary directory';

	debug 'temp dir', $options->{'temp_dir'} if $options->{'verbose'};
}

sub check_option_config {
	return unless defined $options->{'config'};

	if (-e $options->{'config'}) {
		brag_and_exit "Config file '$options->{'config'}' can not be written to" unless -w $options->{'config'};

		# Avoid accidental damage: accept config file only if the file is a proper config file or if it is an empty file
		brag_and_exit "Cowardly refusing to use non-config file '$options->{'config'}'"
			unless defined Config::Tiny->read($options->{'config'}, 'utf8')
				|| (stat($options->{'config'}))[7] == 0;
	} else {
		my $file_creation_error = get_file_creation_error $options->{'config'}, 'Config file';
		brag_and_exit $file_creation_error if defined $file_creation_error;
	}

	debug 'config', $options->{'config'} if $options->{'verbose'};
}

sub check_option_max_items {
	brag_and_exit "Max items number is not a valid number: $options->{'max_items'}"
		unless $options->{'max_items'} =~ /^\s*\d+\s*$/;

	$options->{'max_items'} = int $options->{'max_items'};

	$options->{'max_items'} = $MAX_REQUEST_PAGES * $ITEMS_PER_REQUEST_PAGE
		unless $options->{'max_items'};

	debug 'max items', $options->{'max_items'} if $options->{'verbose'};
}

sub cook_rand_xxxx {
	sprintf "%04X", int rand 0x10000;
}

sub cook_device_uid {
	&cook_rand_xxxx . '-' .
	&cook_rand_xxxx . '-' .
	&cook_rand_xxxx . '-' .
	&cook_rand_xxxx . '-' .
	&cook_rand_xxxx . '-' .
	&cook_rand_xxxx . '-' .
	&cook_rand_xxxx . '-' .
	&cook_rand_xxxx;
}

sub cook_quickauth_request {
	{
		'name'					=> 'quickauth',
		'method'				=> 'POST',
		'url'						=> "$API_URL_BASE/user/quickauth/",
		'post_params'		=> {
			'device_uid'		=> $config->{_}->{'device_uid'},
		},
		'extra_headers'	=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_startlinking_request {
	{
		'name'					=> 'startlinking',
		'method'				=> 'POST',
		'url'						=> "$API_URL_BASE/user/startlinking/",
		'post_params'		=> {
		},
		'extra_headers'	=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_link_request {
	my $oid = shift;

	{
		'name'						=> 'link',
		'method'					=> 'POST',
		'url'							=> "$API_URL_BASE/user/link/",
		'post_params'			=> {
			'device_uid'			=> $config->{_}->{'device_uid'},
			'oid'							=> $oid,
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'401'							=> {
				'error'						=> '401 Unauthorized',
			}
		},
	}
}

sub cook_me_request {
	{
		'name'						=> 'me',
		'method'					=> 'GET',
		'url'							=> "$API_URL_BASE/user/me/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'403'							=> {
				'error'						=> '403 Forbidden',
			}
		},
	}
}

sub cook_videos_request {
	my $show_id = shift;

	{
		'name'						=> 'videos',
		'method'					=> 'GET',
		'url'							=> "$API_URL_BASE/articles/$show_id/videos/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'404'							=> [{
				'error'						=> '404 Not Found',
			}]
		},
	}
}

# TODO: Make sense
sub cook_categories_request {
	{
		'name'						=> 'categories',
		'method'					=> 'GET',
		'url'							=> "$API_URL_BASE/programs/categories/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_programs_request {
	my $page_number = shift;
	my $items_per_page = shift;

	{
		'name'						=> 'programs',
		'method'					=> 'GET',
		'url'							=> "$API_URL_BASE/programs/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
			'X-Result-Define-Thumb-Width'		=> '380',
			'X-Result-Define-Thumb-height'	=> '240',
			'X-Result-Define-Pagination'
				=> $page_number . '/' . $items_per_page,
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_program_articles_request {
	my $program_id = shift;
	my $page_number = shift;
	my $items_per_page = shift;

	{
		'name'						=> 'articles',
		'method'					=> 'GET',
		'url'							=> "$API_URL_BASE/programs/$program_id/articles/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
			'X-Result-Define-Pagination'
				=> $page_number . '/' . $items_per_page,
		},
		'error_overrides'	=> {
			'404'							=> {
				'error'						=> '404 Not Found',
			}
		},
	}
}

sub cook_program_request {
	my $program_id = shift;

	{
		'name'						=> 'articles',
		'method'					=> 'GET',
		'url'							=> "$API_URL_BASE/programs/$program_id/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'404'							=> {
				'error'						=> '404 Not Found',
			}
		},
	}
}

sub cook_article_request {
	my $show_id = shift;

	{
		'name'						=> 'article',
		'method'					=> 'GET',
		'url'							=> "$API_URL_BASE/articles/$show_id/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
			'X-Result-Define-Pagination'	=> '1/20'
		},
		'error_overrides'	=> {
			'404'							=> {
				'error'						=> '404 Not Found',
			}
		},
	}
}

sub write_config {
	$config->write($session->{'config_file_path'}, 'utf8') or die "Error writing config " . $config->errstr();
}

sub cook_auth {
	my $user_id = shift;
	my $device_token = shift;

	'Basic ' . MIME::Base64::encode_base64 "$user_id:$device_token", '';
}

sub call_api {
	my $api_request = shift;

	# TODO: Try implementing via $user_agent->default_headers
	my $headers = HTTP::Headers->new(
		'X-User-Agent'									=> "$DEVICE_NAME; API_CONSUMER_KEY=$API_CONSUMER_KEY",
		'Accept'												=> "application/tvrain.api.$API_VERSION+json",
		'Content-Type'									=> 'application/x-www-form-urlencoded',
	);

	my $encoded_params = $cgi_utils->url_encode_vars($api_request->{'post_params'}, '&') if keys %{$api_request->{'post_params'}};
	$api_request->{'extra_headers'}->{'Content-Length'} = length $encoded_params if $encoded_params;

	foreach my $key (keys %{$api_request->{'extra_headers'}}) {
		$headers->push_header($key => $api_request->{'extra_headers'}->{$key});
	}

	$headers->push_header('Authorization' => $config->{_}->{'auth'}) if defined $config->{_}->{'auth'};

	my $request = HTTP::Request->new(
		$api_request->{'method'},
		$api_request->{'url'},
		$headers,
		$encoded_params
	);

	debug 'request', $request->as_string if $options->{'verbose'};

	my $response = $user_agent->request($request);

	if ($response->is_success) {
		debug 'response', $response->content if $options->{'verbose'};

		return $json->utf8->decode($response->content);
	} else {
		if (defined $api_request->{'error_overrides'}->{$response->code}) {
			debug 'response', 'Executing error override for HTTP return code ' . $response->code if $options->{'verbose'};

			return $api_request->{'error_overrides'}->{$response->code};
		} else {
			die "Error processing “$api_request->{'name'}” API call: " . $response->status_line;
		}
	}
}

sub read_command_line_options {
	my $error_message;
	my $error = tie *STDERR, 'IO::Scalar', \$error_message;

	my $all_went_well = Getopt::Long::GetOptions ($options,
		'help|h',
		'long_help|long-help',
		'verbose|v',
		'simulate|S',
		'first_run|first-run|F',
		'command|c=s',
		'quality|q=s',
		'output_dir|output-dir|d=s',
		'output_file|output-file|o=s',
		'temp_dir|temp-dir|t=s',
		'id|i',
		'yes_all|yes-all|y',
		'config|C=s',
		'max_items|max-items|I=s',
		'wait_for_input|wait-for-input|W=s',
	);

	undef $error;
	untie *STDERR;

	brag_and_exit $error_message unless $all_went_well;
}

sub executable_exist {
	my $command = [shift];

	eval { IPC::Run3::run3($command, \undef, \undef, \undef,) };
	my $exists = $? >= 0;
	undef $?;

	# The run3 call somehow messes utf8 up
	&set_binmode;

	debug 'executable exist', "$command->[0] → $exists" if $options->{'verbose'};

	$exists;
}

sub check_dowloader_exec {
	my $wget_exec = 'wget';

	brag_and_exit "Can not find wget. Please check requirements." unless executable_exist $wget_exec;

	$session->{'wget_exec'} = $wget_exec;

	debug 'wget exec', $session->{'wget_exec'} if $options->{'verbose'};
}

sub check_merge_exec {
	my $mkvmerge_exec = 'mkvmerge';
	my $ffmpeg_exec = 'ffmpeg';

	if (executable_exist $mkvmerge_exec) {
		$session->{'merge_with'} = $MERGE_WITH_MKVMERGE;
	} elsif (executable_exist $ffmpeg_exec) {
		$session->{'merge_with'} = $MERGE_WITH_FFMPEG;
	} else {
		brag_and_exit "Neither mkvmerge nor ffmpeg found. Please check requirements.";
	}

	debug 'merge with', $session->{'merge_with'} if $options->{'verbose'};
}

sub decide_on_executables {
	&check_dowloader_exec;
	&check_merge_exec;
}

sub deal_with_help_requests {
	print $long_help and exit if $options->{'long_help'};

	&brag_and_exit if $options->{'help'};
}

sub check_option_wait_for_input {
	brag_and_exit "Wait for input is not a valid number: $options->{'wait_for_input'}"
		unless $options->{'wait_for_input'} =~ /^\s*\d+\s*$/;

	$options->{'wait_for_input'} = int $options->{'wait_for_input'};

	debug 'wait for input', $options->{'wait_for_input'} if $options->{'verbose'};
}

sub interpret_command_line_options {
	&check_option_command;
	&check_option_quality;
	&check_option_output_dir;
	&check_option_output_file;
	&check_option_temp_dir;
	&check_option_config;
	&check_option_max_items;
	&check_option_wait_for_input;

	debug 'options', dumpit $options if $options->{'verbose'};
}

sub get_show_id {
	brag_and_exit 'No show ID or URL' unless scalar @ARGV;

	$_ = pop @ARGV;

	if (/^\d+$/) {
		$session->{'show_id'} = $_;
	} elsif (/tvrain\.ru.*-(\d+)\/?$/) {
		$session->{'show_id'} = $1;
	} else {
		brag_and_exit "Invalid show ID or URL";
	}

	debug 'show id', $session->{'show_id'} if $options->{'verbose'};
}

sub get_program_id {
	brag_and_exit 'No program ID' unless scalar @ARGV;

	$_ = pop @ARGV;

	if (/^\s*(\d+)\s*$/) {
		$session->{'program_id'} = $1;
	} else {
		brag_and_exit "Invalid program ID";
	}

	debug 'program id', $session->{'program_id'} if $options->{'verbose'};
}

sub set_config_file_path {
	$session->{'config_file_path'} = 	defined $options->{'config'}
		? $options->{'config'}
		: File::HomeDir->my_home . "/$CONFIG_FILE_NAME";

	debug 'config file path', $session->{'config_file_path'} if $options->{'verbose'};
}

sub create_clean_config {
	$config = Config::Tiny->new;
	$config->{_}->{'device_uid'} = &cook_device_uid;

	&write_config;

	print "New device uid created\n";
}

sub read_config {
	if ($options->{'first_run'}) {
		print "Resetting config file per user request\n";
		&create_clean_config;
	} else {
		$config = Config::Tiny->read($session->{'config_file_path'}, 'utf8');

		unless (defined $config && defined $config->{_}->{'device_uid'}) {
			print "Empty / invalid config file → recreating\n";
			&create_clean_config;
		}
	}

	debug 'device uid', $config->{_}->{'device_uid'} if $options->{'verbose'};
}

sub save_default_temp_dir {
	my $temp_dir = shift;

	$config->{_}->{'temp_dir'} = $temp_dir;

	print "Default temporary dir is set to '$temp_dir'\n";

	&write_config;
}

sub ask_user_for_deafult_temp_dir {
	my $dir_wrieable_error;
	my $temp_dir;

	do {
		print "Please set the default temporary directory.\nJust press 'Enter' to each time use current directory.\n:";

		$temp_dir = <STDIN>;
		chomp $temp_dir;
		$temp_dir =~ s/^\s+//;
		$temp_dir =~ s/\s+$//;

		if ($temp_dir eq '') {
			$temp_dir = '.'
		} elsif ($temp_dir =~ /^\.{1,2}(?:\/.*)?$/) {
			$temp_dir = Cwd::realpath $temp_dir;
		} elsif ($temp_dir =~ /^\~(\/.*)?$/) {
			$temp_dir = File::HomeDir->my_home . $1;
		}

		$dir_wrieable_error = get_dir_wrieable_error $temp_dir, 'Default temporary directory';

		print $dir_wrieable_error, "\n\n" if defined $dir_wrieable_error;
	} while (defined $dir_wrieable_error);

	return $temp_dir;
}

sub decide_on_temp_dir {
	if (defined $config->{_}->{'temp_dir'}) {
		if (defined $options->{'temp_dir'}) {
			# Use options, no checking needed
			$session->{'temp_dir'} = $options->{'temp_dir'};
		} else {
			# Check and use config
			$session->{'temp_dir'} = check_if_dir_is_writeable $config->{_}->{'temp_dir'}, 'Default temporary directory';
		}
	} else {
		if (defined $options->{'temp_dir'}) {
			# Use options and write it to config
			save_default_temp_dir $options->{'temp_dir'};

			$session->{'temp_dir'} = $options->{'temp_dir'};
		} else {
			# It's first run: ask user, check, write to config and use
			save_default_temp_dir &ask_user_for_deafult_temp_dir;

			$session->{'temp_dir'} = $config->{_}->{'temp_dir'};
		}
	}

	check_if_dir_is_writeable $options->{'temp_dir'}, 'Temporary directory';
}

sub link_if_not_linked {
	return if defined $config->{_}->{'auth'};

	print "Absent / invalid authentication → linking to account\n";

	my $startlinking_response = call_api &cook_startlinking_request;

	print "Linking code:\n  $startlinking_response->{'code'}\n\n$linking_hint";

	my $link_request = cook_link_request $startlinking_response->{'oid'};

	print "Trying to link…\n";
	my $link_response;

	do {
		# TODO: Add some kind of sandwatch
		sleep $LINK_POLL_TIMEOUT_SEC;

		$link_response = call_api $link_request;
	} until (defined $link_response->{'user_id'});

	print "Link established\n";

	$config->{_}->{'auth'} = cook_auth $link_response->{'user_id'}, $link_response->{'device_token'};

	&write_config;
}

sub get_me_to_check_auth {
	my $me_response = call_api &cook_me_request;

	brag_and_exit "Authentication failure${relink_hint}" if defined $me_response->{'error'};

	$session->{'me'} = $me_response;

	die "Malformed 'me' response" unless defined $session->{'me'}->{'vip'};

	brag_and_exit "Subscription expired :-(\nPlease visit TVRain.ru and pay them, then come back." if $session->{'me'}->{'vip'} < 0;

	print "Login Ok, subscription active for $session->{'me'}->{'vip'} more days\n\n";
}

sub get_videos {
	return unless $session->{'article'}->{'has_video'};

	my $videos_response = call_api cook_videos_request $session->{'show_id'};

	brag_and_exit "Video not found\nPlease check show ID / URL" if defined $videos_response->[0]->{'error'};

	$session->{'videos'} = $videos_response;

	debug 'videos', dumpit $session->{'videos'} if $options->{'verbose'};

	brag_and_exit 'Server lists no videos for the show id ' . $session->{'show_id'} unless defined $session->{'videos'}->[0]->{'mp4'};
}

# TODO: Make sense
sub get_categories {
	my $categories_response = call_api cook_categories_request;

	#brag_and_exit "Can not get programs" if defined $categories_response->[0]->{'error'};

	$session->{'categories'} = $categories_response;

	debug 'categories', dumpit $session->{'categories'} if $options->{'verbose'};
	# {
	#   current_page → 1
	#   elements → {
	#     1 → Программы
	#     2 → Архив программ
	#     3 → Мини-жанр
	#   }
	#   total_pages → 1
	# }
}

sub get_article {
	die 'No show id' unless $session->{'show_id'};

	my $article_response = call_api cook_article_request $session->{'show_id'};

	brag_and_exit "Article not found\nPlease check show ID / URL" if defined $article_response->{'error'};

	brag_and_exit "Server returned malformed article data for show ID " . $session->{'show_id'}
		unless defined $article_response->{$session->{'show_id'}};
	$session->{'article'} = $article_response->{$session->{'show_id'}};
	$session->{'program_id'} = $session->{'article'}->{'program_id'};

	debug 'article', dumpit $session->{'article'} if $options->{'verbose'};
}

sub get_program {
	die 'No program id' unless $session->{'program_id'};

	my $program_response = call_api cook_program_request $session->{'program_id'};

	return if defined $program_response->{'error'};

	return unless defined $program_response->{$session->{'program_id'}};
	$session->{'program'} = $program_response->{$session->{'program_id'}};

	debug 'program', dumpit $session->{'program'} if $options->{'verbose'};
}

sub guess_article_name_from_videos {
	my $common;

	for (my $i = 0; $i < scalar @{$session->{'videos'}}; $i++) {
		$_ = $session->{'videos'}->[$i]->{'name'};

		s/\s+/ /g;

		# If the name is not prceded with smth like 1/3 there is no common name
		return undef unless /^\d+\W\d+\s+(.*)$/;
		my $challenge = $1;

		$common ||= $challenge;

		next if $challenge eq $common;

		# Update common if it is merely a shorter version of challenge
		$common = $challenge and next if $challenge =~ /^\Q$common\E/;

		# Ignore challenge if it is just a shorter version of common
		next if $common =~ /^\Q$challenge\E/;

		# Video fragment names are significantly different so we give up
		# TODO: Cancatenete significantly different names
		return undef;
	}

	return $common;
}

sub cook_extension {
	return 'mkv' if $options->{'command'} eq $COMMAND_MERGE;

	return 'mp4' if $options->{'command'} eq $COMMAND_SAVE;

	return 'm3u8' if $options->{'command'} eq $COMMAND_PLAYLIST;

	return 'txt' if $options->{'command'} eq $COMMAND_PROGRAM_ARTICLES;

	die 'Unsupported command';
}

sub get_article_name {
	$_ = $session->{'article'}->{'name'};
	$_ ||= &guess_article_name_from_videos;
	$_ ||= $session->{'videos'}->[0]->{'name'};

	return $_;
}

sub get_program_name {
	die 'No program ID' unless $session->{'program_id'};
	$_ = $session->{'program_id'} unless $session->{'program'};

	$_ = $session->{'program'}->{'name'};

	s/^\s*//;
	s/\s*$//;

	return $_;
}

sub clean_string_for_file_name {
	$_= shift;

	s/^\s+//;
	s/\s+$//;
	s/\s*:+\s*/ - /g;
	s/[:#\\\/\*]+/./g;
	s/[\{\<]/[/g;
	s/[\}\>]/[]/g;
	s/\"(.*?)\"/«$1»/g;
	s/\"//g;
	s/\?+/⁇/g;

	return $_;
}

sub truncate_string_and_put_ellipsis {
	$_ = shift;
	my $max_length = shift;
	my $min_length = shift;
	my $ellipsis = shift;

	$min_length ||= 1;
	$ellipsis ||= '…';

	if (length $_ > $max_length) {
		$max_length -= length $ellipsis;
		s/^(.{$max_length}).*$/${1}${ellipsis}/
			unless s/^(.{$min_length,$max_length})\s.*$/${1}${ellipsis}/;
	}

	return $_;
}

sub fit_name_and_ext_to_file_name {
	my $name = shift; # Assumed to be already clean
	my $ext = shift; # No dot

	my $name_max_length = $MAX_FILE_NAME_LENGTH - 1 - length $ext;

	$name = truncate_string_and_put_ellipsis $name, $name_max_length, $MIN_NAME_PART_LENGTH;

	return "${name}.${ext}";
}

sub fit_program_and_article_names_and_ext_to_file_name {
	my $program_name = shift; # Assumed to be already clean
	my $article_name = shift; # Assumed to be already clean
	my $ext = shift; # No dot

	my $name_max_length = $MAX_FILE_NAME_LENGTH - 1 - length $ext;

	my $name = $program_name . $NAME_PARTS_CONNECTOR . $article_name;

	if (length $name > $name_max_length) {
		$program_name = truncate_string_and_put_ellipsis $program_name, $MAX_PROGRAM_NAME_LENGTH, $MIN_NAME_PART_LENGTH;

		$name = truncate_string_and_put_ellipsis $program_name . $NAME_PARTS_CONNECTOR . $article_name,
			$name_max_length, $MIN_NAME_PART_LENGTH;
	}

	return "${name}.${ext}";
}

sub cook_article_file_name {
	my $name;

	my $ext = &cook_extension;

	if ($options->{'id'}) {
		return fit_name_and_ext_to_file_name $session->{'show_id'}, $ext;
	} else {
		my $article_name = &clean_string_for_file_name(&get_article_name);

		die 'No article name' unless $article_name;

		my $program_name = &clean_string_for_file_name(&get_program_name);

		return $program_name
			? fit_program_and_article_names_and_ext_to_file_name
				$program_name, $article_name, $ext
			: fit_name_and_ext_to_file_name $article_name, $ext;
	}
}

sub cook_program_file_name {
	my $name;

	my $ext = &cook_extension;

	my $program_name = $options->{'id'}
		? $session->{'program_id'}
		: &clean_string_for_file_name(&get_program_name);

	return fit_name_and_ext_to_file_name $program_name, $ext;
}

sub cook_file_name {
	return $PROGRAMS_FILE_NAME if $options->{'command'} eq $COMMAND_PROGRAMS_LIST;

	return &cook_program_file_name if $options->{'command'} eq $COMMAND_PROGRAM_ARTICLES;

	return &cook_article_file_name;
}

sub cook_output_dir {
	return $options->{'output_dir'} if defined $options->{'output_dir'};

	return check_if_dir_is_writeable '.', 'Current directory';
}

sub need_output_path {
	return 0 if $options->{'command'} eq $COMMAND_INFO;

	return 0 if $options->{'command'} eq $COMMAND_QUIT;

	return 1;
}

sub need_one_article {
	return 0 if $options->{'command'} eq $COMMAND_PROGRAMS_LIST;

	return 0 if $options->{'command'} eq $COMMAND_PROGRAM_ARTICLES;

	return 1;
}

sub need_one_program {
	return 1 if $options->{'command'} eq $COMMAND_PROGRAM_ARTICLES;

	return 0;
}

sub need_program_id {
	return 1 if $options->{'command'} eq $COMMAND_PROGRAM_ARTICLES;

	return 0;
}

sub need_a_temp_dir {
	return 1 if $options->{'command'} eq $COMMAND_MERGE;

	return 1 if $options->{'command'} eq $COMMAND_INTERACTIVE;

	return 0;
}

sub need_video_urls {
	return 1 if $options->{'command'} eq $COMMAND_MERGE;

	return 1 if $options->{'command'} eq $COMMAND_SAVE;

	return 1 if $options->{'command'} eq $COMMAND_PLAYLIST;

	return 1 if $options->{'command'} eq $COMMAND_INTERACTIVE;

	return 0;
}

# TODO: Make as many paths here as command actualy requires
sub decide_on_output_path {
	$session->{'output_path'} = defined $options->{'output_file'}
		? $options->{'output_file'}
		: check_if_file_is_writeable &cook_output_dir . '/' . &cook_file_name, 'Output path';

	debug 'output path', $session->{'output_path'} if $options->{'verbose'};
}

sub get_quality_url_key {
	my $quality = shift;

	return '1080p' if $quality eq $QUALITY_FH;
	return '720p'  if $quality eq $QUALITY_HD;
	return '480p'  if $quality eq $QUALITY_SD;
	return '360p'  if $quality eq $QUALITY_LO;

	die "Unexpected quality";
}

sub get_quality_name {
	return get_quality_url_key shift;
}

sub clean_string_for_backticks {
	$_ = shift;
	s/'/'\\''/g;
	$_;
}

sub get_wget_error {
	my $wget_exit_code = shift;

	return $WGET_ERRORS[$wget_exit_code] if defined $WGET_ERRORS[$wget_exit_code];

	return 'Unrecognized error';
}

sub download_url_to_path {
	my $url = shift;
	my $output_path = shift;

	my $wget_call = [
		$session->{'wget_exec'},
		'-O',
		$output_path,
		$url,
	];

	debug 'wget call', join "\n", @$wget_call if $options->{'verbose'};

	my $try_number = 0;
	until (-f $output_path) {
		brag_and_exit "Can't get video segment witin a reasonable number of retries" if ++$try_number >= $SAME_VIDEO_MAX_RETRIES;

		IPC::Run3::run3($wget_call) unless $options->{'simulate'};
		my $wget_exit_code = $? >> 8;
		undef $?;

		die "Wget failed: " . get_wget_error $wget_exit_code if $wget_exit_code;

		# Check if server returned a video or just an error-placeholder
		last if -s $output_path > $VIDEO_CANT_BE_SO_SMALL;
		unlink $output_path;
		sleep $SECONDS_BETWEEN_SAME_VIDEO_RETRIES;
	}

	print "$output_path\n";
}

sub cook_temp_video_path {
	my $url = shift;

	$url =~ /\/([^\/\?]+)[^\/]*$/;

	my $remote_file_name = $1;
	$remote_file_name ||= 'video.mp4';

	$session->{'temp_dir'} . '/tvrain-' . &cook_rand_xxxx . '-' . $remote_file_name;
}

sub cook_no_quality_error_message {
	my $quality = shift;

	my $quality_string =
		$quality eq $QUALITY_FH ? 'full hd' :
		$quality eq $QUALITY_HD ? 'high definition' :
		$quality eq $QUALITY_SD ? 'standard definition' :
		$quality eq $QUALITY_LO ? 'low bitrate' :
		'requested quality';

	"The $quality_string video is not available";
}

sub download_temp_video {
	my $video = $session->{'videos'}->[shift];

	my $url = $video->{'mp4'}->{get_quality_url_key $options->{'quality'}};

	brag_and_exit cook_no_quality_error_message $options->{'quality'} unless $url;

	my $temp_video_path = cook_temp_video_path $url;

	download_url_to_path $url, $temp_video_path;

	$temp_video_path;
}

sub download_temp_videos {
	my @temp_videos;

	for (my $i = 0 ; $i < scalar @{$session->{'videos'}}; $i++) {
		push @temp_videos, download_temp_video $i;
	}

	$session->{'temp_videos'} = \@temp_videos;
}

sub cook_ffmpeg_list_file_path {
	my $ffmpeg_list_file_path = $session->{'temp_dir'} . '/get-tvrain-mux-list-' . $session->{'show_id'} . '-' . &cook_rand_xxxx . '.txt';

	debug 'ffmpeg list file path', $ffmpeg_list_file_path if $options->{'verbose'};

	$ffmpeg_list_file_path;
}

sub merge_temp_videos_with_ffmpeg {
	my $list_file_path = &cook_ffmpeg_list_file_path;
	open LIST, '>', $list_file_path or die "Can not open ffmpeg list file";

	printf LIST "# Show ID: %s\n", $session->{'show_id'};

	for (my $i = 0 ; $i < scalar @{$session->{'temp_videos'}}; $i++) {
		printf LIST "file '%s'\n", $session->{'temp_videos'}->[$i];
	}

	close LIST;

	my $ffmpeg_call = [
		'ffmpeg',
		'-f',
		'concat',
		'-i',
		$list_file_path,
		'-c',
		'copy',
		$session->{'output_path'},
	];

	debug 'ffmpeg call', join "\n", @$ffmpeg_call if $options->{'verbose'};

	IPC::Run3::run3($ffmpeg_call) unless $options->{'simulate'};
	my $ffmpeg_exit_code = $? >> 8;
	undef $?;

	die "ffmpeg failed" if $ffmpeg_exit_code > 1;

	unlink $list_file_path;
}

sub merge_temp_videos_with_mkvmerge {
	my $mkvmerge_call = ['mkvmerge'];

	push @$mkvmerge_call, '-o', $session->{'output_path'};

	my $put_a_plus = 0;
	for (my $i = 0 ; $i < scalar @{$session->{'temp_videos'}}; $i++) {
		my $buffer = $put_a_plus
			? '+'
			: '';

		$buffer .= $session->{'temp_videos'}->[$i];

		push @$mkvmerge_call, $buffer;

		$put_a_plus = 1;
	}

	debug 'mkvmerge call', join "\n", @$mkvmerge_call if $options->{'verbose'};

	IPC::Run3::run3($mkvmerge_call) unless $options->{'simulate'};
	my $mkvmerge_exit_code = $? >> 8;
	undef $?;

	die "mkvmerge failed" if $mkvmerge_exit_code > 1;
}

sub merge_temp_videos {
	&merge_temp_videos_with_mkvmerge if $session->{'merge_with'} eq $MERGE_WITH_MKVMERGE;
	&merge_temp_videos_with_ffmpeg if $session->{'merge_with'} eq $MERGE_WITH_FFMPEG;
}

sub delete_temp_videos {
	return if $options->{'simulate'};

	for (my $i = 0 ; $i < scalar @{$session->{'temp_videos'}}; $i++) {
		unlink $session->{'temp_videos'}->[$i] or warn "Can not delete temporary video $session->{'temp_videos'}->[$i]";
	}
}

sub merge_it {
	&download_temp_videos;
	&merge_temp_videos;
	&delete_temp_videos;

	print "$session->{'output_path'}\n";
}

sub download_video_to_save {
	my $number = shift;

	my $video = $session->{'videos'}->[$number];

	my $url = $video->{'mp4'}->{get_quality_url_key $options->{'quality'}};

	$session->{'output_path'} =~ /^(.*\/)([^\/]+)$/;
	my $save_to_path = sprintf '%s%02i-%s', $1, $number + 1, $2;

	download_url_to_path $url, $save_to_path;
}

sub save_several_videos {
	for (my $i = 0 ; $i < scalar @{$session->{'videos'}}; $i++) {
		download_video_to_save $i;
	}
}

sub save_one_video {
	my $video = $session->{'videos'}->[0];

	my $url = $video->{'mp4'}->{get_quality_url_key $options->{'quality'}};

	download_url_to_path $url, $session->{'output_path'};
}

sub save_it {
	scalar @{$session->{'videos'}} == 1
		? &save_one_video
		: &save_several_videos;
}

sub cook_m3u_header {
	"#EXTM3U\n\n";
}

sub cook_m3u_item {
	my $video = $session->{'videos'}->[shift];

	sprintf "#EXTINF:%.2f, До///дь - %s\n%s\n\n",
		$video->{'duration'} / 1000,
		$video->{'name'},
		$video->{'mp4'}->{get_quality_url_key $options->{'quality'}};
}

sub cook_m3u_footer {
	'';
}

sub playlist_it {
	my $buffer = '';

	$buffer .= &cook_m3u_header;

	for (my $i = 0 ; $i < scalar @{$session->{'videos'}}; $i++) {
		$buffer .= cook_m3u_item $i;
	}

	$buffer .= &cook_m3u_footer;

	debug 'playlist', $buffer if $options->{'verbose'};

	open PLS, "> $session->{'output_path'}" or die "Can not open output file to write $session->{'output_path'}";
	print PLS $buffer or die "Can not write to output file $session->{'output_path'}";
	close PLS;

	print "$session->{'output_path'}\n";
}

# Part of server error workaround
sub video_segment_has_resolutions {
	my $video = shift;

	return ref $video->{'mp4'} eq 'HASH';
}

sub list_video_resolutions {
	# $session->{'videos'}->[$i]
	my $video = shift;

	# A workaround for the server returning an empty array instead of hash when there are no video resolutions
	return 'None' unless video_segment_has_resolutions $video;

	my @resolutions;
	foreach my $quality ($QUALITY_FH, $QUALITY_HD, $QUALITY_SD, $QUALITY_LO) {
		push @resolutions, get_quality_name $quality if defined $video->{'mp4'}->{get_quality_url_key $quality};
	}

	return scalar @resolutions
		? join ', ', @resolutions
		: 'None';
}

sub get_total_duration {
	return 0 unless $session->{'article'}->{'has_video'};

	my $total_ms = 0;

	for (my $i = 0 ; $i < scalar @{$session->{'videos'}}; $i++) {
		# A workaround for server returinig zero video segment duration
		return 0 unless $session->{'videos'}->[$i]->{'duration'};

		$total_ms += $session->{'videos'}->[$i]->{'duration'};
	}

	return $total_ms;
}

sub info_it {
	my $number_of_segments = $session->{'article'}->{'has_video'}
		? scalar @{$session->{'videos'}}
		: 0;

	printf 'Article:
  Program name:   %s
  Program ID:     %s
  Show name:      %s
  Show ID:        %s
  Timestamp:      %s
  URL:            %s
  Video segments: %i
  Complete show:  %s
  Total duration: %s

',
	get_program_name,
	$session->{'program_id'},
	$session->{'article'}->{'name'},
	$session->{'show_id'},
	$session->{'article'}->{'date_active_start'},
	$SITE_URL_BASE . $session->{'article'}->{'url'},
	$number_of_segments,
	boolean_to_string($session->{'article'}->{'is_full'}),
	millisec_to_human_readeble(&get_total_duration);

	for (my $i = 0 ; $i < $number_of_segments; $i++) {
		my $video = $session->{'videos'}->[$i];

		printf 'Segment #%i:
  Name:        %s
  Duration:    %s
  Resolutions: %s

', $i + 1, $video->{'name'}, millisec_to_human_readeble($video->{'duration'}), list_video_resolutions($video);
	}
}

sub print_meter {
	my $pretext = shift;
	my $filled = shift;
	my $total = shift;

	STDOUT->autoflush(1);
	print "$pretext " . '*' x $filled . '.' x ($total - $filled) . "\r";
	STDOUT->autoflush(0);
}

sub reset_after_meter {
	STDOUT->autoflush(1);
	print "\n";
	STDOUT->autoflush(0);
}

sub cook_pages {
	my $total_pages = shift;

	die "Bad total pages number $total_pages" if $total_pages < 1;

	my $max_pages = ceiling $options->{'max_items'} / $ITEMS_PER_REQUEST_PAGE;

	return $max_pages < $total_pages
		? $max_pages
		: $total_pages;
}

sub programs_list_it {
	my $pages;
	my $programs_response;
	my $current_page = 0;
	my $programs = [];

	do {
		++$current_page;

		$programs_response = call_api cook_programs_request($current_page, $ITEMS_PER_REQUEST_PAGE);
		brag_and_exit "Can not get programs page $current_page" unless $programs_response->{'current_page'};

		$pages ||= int $programs_response->{'total_pages'};

		push @{$programs}, @{$programs_response->{'elements'}};

		print_meter "Retrieving programs", $current_page, $pages unless $options->{'verbose'};
	} while( $current_page < $pages );

	reset_after_meter unless $options->{'verbose'};

	$session->{'programs'} = $programs;

	debug 'programs', dumpit $session->{'programs'} if $options->{'verbose'};

	my $number_of_programs = scalar @{$session->{'programs'}};
	printf "Got %i programs\n", $number_of_programs;

	open PROGRAMS, "> $session->{'output_path'}" or die "Can not open output file to write $session->{'output_path'}";
	for (my $i = 0; $i < $number_of_programs; $i++) {
		printf PROGRAMS "%s\t%s\n", $session->{'programs'}->[$i]->{'id'}, $session->{'programs'}->[$i]->{'name'}
			or die "Can not write to output file $session->{'output_path'}";
	}
	close PROGRAMS;

	print "$session->{'output_path'}\n";
}

sub has_video_to_string {
	return $_[0]
		? 'Video'
		: '–';
}

sub is_full_to_string {
	return $_[0]
		? 'Complete show'
		: 'Fragment';
}

sub program_articles_it {
	my $pages;
	my $articles_response;
	my $current_page = 0;
	my $articles = [];

	do {
		++$current_page;

		$articles_response = call_api cook_program_articles_request(
			$session->{'program_id'}, $current_page, $ITEMS_PER_REQUEST_PAGE);

		brag_and_exit "No articles found\nPlease check program ID" if defined $articles_response->{'error'};
		brag_and_exit "Can not get program articles page $current_page" unless $articles_response->{'current_page'};

		$pages ||= cook_pages int $articles_response ->{'total_pages'};

		push @{$articles}, @{$articles_response->{'elements'}};

		print_meter "Retrieving articles", $current_page, $pages unless $options->{'verbose'};
	} while( $current_page < $pages );

	reset_after_meter unless $options->{'verbose'};

	splice @{$articles}, $options->{'max_items'} if scalar @{$articles} > $options->{'max_items'};

	$session->{'articles'} = $articles;

	debug 'articles', dumpit $session->{'articles'} if $options->{'verbose'};

	my $number_of_articles = scalar @{$session->{'articles'}};
	printf "Got %i articles\n", $number_of_articles;

	open ARTICLES, "> $session->{'output_path'}" or die "Can not open output file to write $session->{'output_path'}";
	for (my $i = 0; $i < $number_of_articles; $i++) {
		printf ARTICLES "%s\t%s\t%s\t%s\t%s\n",
			$session->{'articles'}->[$i]->{'id'},
			$session->{'articles'}->[$i]->{'date_active_start'},
			has_video_to_string($session->{'articles'}->[$i]->{'has_video'}),
			is_full_to_string($session->{'articles'}->[$i]->{'is_full'}),
			$session->{'articles'}->[$i]->{'name'}
			or die "Can not write to output file $session->{'output_path'}";
	}
	close ARTICLES;

	print "$session->{'output_path'}\n";
}

sub cook_command_prompt_matrix {
	my $default_command = shift;
	my $count_length = shift;

	die "Bad default command $default_command"
		unless $default_command eq $COMMAND_MERGE
		|| $default_command eq $COMMAND_SAVE
		|| $default_command eq $COMMAND_PLAYLIST
		|| $default_command eq $COMMAND_QUIT;

	my $merge_is_deafult = $default_command eq $COMMAND_MERGE
		? $COMMAND_PROMPT_DEFAULT_MARKER
		: '';

	my $save_is_deafult = $default_command eq $COMMAND_SAVE
		? $COMMAND_PROMPT_DEFAULT_MARKER
		: '';

	my $playlist_is_deafult = $default_command eq $COMMAND_PLAYLIST
		? $COMMAND_PROMPT_DEFAULT_MARKER
		: '';

	my $quit_is_deafult = $default_command eq $COMMAND_QUIT
		? $COMMAND_PROMPT_DEFAULT_MARKER
		: '';

	"\rYou can [m]erge ${merge_is_deafult}or [s]ave ${save_is_deafult}videos, create [p]laylist ${playlist_is_deafult}or [q]uit ${quit_is_deafult}(%${count_length}i): "
}

sub print_command_prompt {
	my $command_prompt_matrix = shift;
	my $count = shift;

	STDOUT->autoflush(1);
	printf $command_prompt_matrix, $count;
	STDOUT->autoflush(0);
}

sub interpret_command_prompt_key {
	my $default_command = shift;
	$_ = shift;

	return $default_command unless defined $_;

	my $command = $COMMAND_PROMPT_CHAR_TO_COMMAND->{lc $_};
	return $command if defined $command;

	return $default_command if /[\r\n]/;

	return undef;
}

sub cook_command_prompt_input_eval {
	'use Term::ReadKey; ' .
	'ReadMode 3; ' .
	'my $key = ReadKey ' . $COMMAND_PROMPT_TIME_STEP . '; ' .
	'ReadMode 0; ' .
	'return $key; '
}

sub get_command_prompt_input {
	my $command_prompt_matrix = shift;
	my $command_prompt_input_eval = shift;

	print "\n";

	my $start_time = time;
	my $time_left = $options->{'wait_for_input'};
	my $command;

	while ($time_left) {
		print_command_prompt $command_prompt_matrix, $time_left;

		$_ = eval $command_prompt_input_eval;

		$time_left = $options->{'wait_for_input'} - (time - $start_time);

		next unless defined $_;

		print $_ unless /[\r\n]/;

		last;
	}

	print "\n";
	return $_;
}

sub ask_for_further_command {
	my $default_command = shift;

	return $default_command unless $options->{'wait_for_input'};

	my $command_prompt_matrix = cook_command_prompt_matrix $default_command, length "$options->{'wait_for_input'}";
	my $command_prompt_input_eval = &cook_command_prompt_input_eval;

	my $command;
	while (1) {
		$command = interpret_command_prompt_key $default_command, 
			get_command_prompt_input $command_prompt_matrix, $command_prompt_input_eval;

		last if defined $command;

		print "Unknown command, please try again\n";
	}

	return $command;
}

sub do_the_job {
	&merge_it if $options->{'command'} eq $COMMAND_MERGE;

	&save_it if $options->{'command'} eq $COMMAND_SAVE;

	&playlist_it if $options->{'command'} eq $COMMAND_PLAYLIST;

	&info_it if $options->{'command'} eq $COMMAND_INFO;

	&programs_list_it if $options->{'command'} eq $COMMAND_PROGRAMS_LIST;

	&program_articles_it if $options->{'command'} eq $COMMAND_PROGRAM_ARTICLES;
}

sub proceed_to_new_command {
	my $new_command = shift;

	return if $new_command eq $options->{'command'};

	push @{$session->{'command_stack'}}, $options->{'command'};

	$options->{'command'} = $new_command;

	debug 'proceed to new command', $options->{'command'} if $options->{'verbose'};
	debug 'command stack', dumpit $session->{'command_stack'} if $options->{'verbose'};
}

sub decide_on_best_article_command {
	my $number_of_segments = scalar @{$session->{'videos'}};

	brag_and_exit "No video in this article" unless $number_of_segments;

	my $new_command =  $number_of_segments > 1
		? $COMMAND_MERGE
		: $COMMAND_SAVE;

	debug 'best article command', $new_command if $options->{'verbose'};

	return $new_command;
}

sub do_interactive {
	&info_it;

	proceed_to_new_command ask_for_further_command &decide_on_best_article_command;
}

sub change_to_info_if_no_video {
	return if $session->{'article'}->{'has_video'};

	printf "NO VIDEO: Server says there's no video in this article.\n\n";
	proceed_to_new_command $COMMAND_INFO;
}

# A workaround for a serverside bug
sub change_to_info_unless_got_resolutions {
	foreach my $video (@{$session->{'videos'}}) {
		unless (video_segment_has_resolutions $video) {
			print "SERVER ERROR: No video URL(s) for at least one segment, see below.\n\n";
			proceed_to_new_command $COMMAND_INFO;
			return;
		}
	}
}

sub update_command {
	&change_to_info_if_no_video if &need_video_urls;

	&change_to_info_unless_got_resolutions if &need_video_urls;

	&do_interactive if $options->{'command'} eq $COMMAND_INTERACTIVE;
}

sub main {
	&set_binmode;
	&guess_if_verbose;
	&check_modules;
	&init;
	&set_options_defaults;
	&read_command_line_options;
	&deal_with_help_requests;
	&interpret_command_line_options;
	&decide_on_executables;
	&get_show_id if &need_one_article;
	&get_program_id if &need_program_id;
	&set_config_file_path;
	&read_config;
	&decide_on_temp_dir if need_a_temp_dir;
	&link_if_not_linked;
	&get_me_to_check_auth;
	&get_article if &need_one_article;
	&get_program if &need_one_article || &need_one_program;
	&get_videos if &need_one_article;
	&update_command;
	&decide_on_output_path if &need_output_path;
	&do_the_job;
}


### Run

&main;
