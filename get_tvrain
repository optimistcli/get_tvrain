#!/usr/bin/perl

###
###	⛈	optimistiCli: TVRain.ru command line client intended to provide legitimate paying users access to the video archive.
###

use utf8;
use strict;

our $usage = 'Usage:
  get_tvrain [-h] [-v] [-F] [-c <merge|save|pls>] [-q <hd|sd|lo>] 
             [-d <output dir>] [-o <output file name>] [-t <temp dir>] 
             [-i] [-y] [-C <config file>] <Video ID | Page with video URL>

TVRain.ru command line client intended to provide access to the video archive 
for registered paying users.

Typical use:
  get_tvrain http://tvrain.ru/teleshow/reportazh/the_rain_is_falling-123456/

If all goes well this will resut with the "Дождь идет.mkv" file in the 
current directory,

Options:
  -h Show useage and exit
  -v Verbose output, prints a lot of debugging stuff to STDERR
  -F Force first run, resets all options, requires device linking
  -c Command, instructs get_tvrain what to do:
       merge - downloads all parts of the video and merges them into one 
               matroska file, requires temp directory for downloaded parts,
               this is the default vommand
       save  - saves each part of the video as is
       pls   - does not download any video, saves a playlist with video URLs
  -q Video quality selector, available options are:
       hd - high definition aka 720p (default)
       sd - standard definition aka 480p
       lo - low bitrate aka 360p
  -d Write output file(s) to the specified directory, defaults to current 
     directory
  -o Set output file(s) name, if ommited the article / feature name is used 
     to compose the file name(s); overrides -d and -i
  -t Use specified directory to temporarely store downloaded video parts for
     the "merge" command, if ommited looks up temp_dir in the configuration
     file, which defaults to the current directory
  -i Use video ID for the file(s) name
  -y Override output file(s) in case of naming conflict, if not specified 
     file name(s) will be changed to avoid overwriting
  -C Use specified configuration faile instaed of the default one

Configuration file:
  // TODO: Explain where it is, what its format is, how is it created

First run:
  // TODO: Explain what happens on the first run, how to re-run it

Linking:
  // TODO: Explain what device linking is, when it happens, how to re-run it

Examples:
  // TODO: Provide a few typical use cases
';

use open IO  => ":encoding(utf8)";
binmode STDOUT, ":utf8";
binmode STDERR, ":utf8";

use Env qw(HOME);
use Config::Tiny;
use HTTP::Headers;
use HTTP::Request;
use CGI::Utils;
use LWP::UserAgent;
use JSON;
use MIME::Base64 qw(encode_base64);
use Getopt::Long qw(:config no_ignore_case require_order bundling);


### Constants

our $CONFIG_FILE_NAME = '.get_tvrain.conf';
our $DEVICE_NAME = 'JaneErye Client'; #'optimistiCli';
our $URL_BASE = 'https://api.tvrain.ru/api_v2';
our $API_CONSUMER_KEY = 'a908545f-80af-4f99-8dac-fb012cec';
our $API_VERSION = '2.13';
our $LINK_POLL_TIMEOUT_SEC=15;


### Globals

our $config;
our $config_file_path;
our $cgi_utils;
our $user_agent;
our $me;
our $options;
our $video_id;

### Init

$config_file_path = "$HOME/$CONFIG_FILE_NAME";
$cgi_utils = CGI::Utils->new;
$user_agent = LWP::UserAgent->new;

# Set options defaults
$options = {
	'verbose'	=> 0,
};

### Functions

sub debug {
	my $title = shift;
	my $text = shift;
	
	$title = uc $title;
	print STDERR "============ $title START ============\n$text\n============= $title END =============\n\n";
}

sub cook_rand_xxxx {
	sprintf "%04X", int rand 0x10000;
}

sub cook_device_uid {
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx;
}

sub cook_quickauth_request {
	{
		'name'					=> 'quickauth',
		'method'				=> 'POST',
		'url'						=> "$URL_BASE/user/quickauth/",
		'post_params'		=> {
			'device_uid'		=> $config->{_}->{'device_uid'},
		},
		'extra_headers'	=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_startlinking_request {
	{
		'name'					=> 'startlinking',
		'method'				=> 'POST',
		'url'						=> "$URL_BASE/user/startlinking/",
		'post_params'		=> {
		},
		'extra_headers'	=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_link_request {
	my $oid = shift;

	{
		'name'						=> 'link',
		'method'					=> 'POST',
		'url'							=> "$URL_BASE/user/link/",
		'post_params'			=> {
			'device_uid'			=> $config->{_}->{'device_uid'},
			'oid'							=> $oid,
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'401'							=> {
				'error'						=> '401 Unauthorized',
			}
		},
	}
}

sub cook_me_request {
	{
		'name'						=> 'me',
		'method'					=> 'GET',
		'url'							=> "$URL_BASE/user/me/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_videos_request {
	my $video_id = shift;

	{
		'name'						=> 'videos',
		'method'					=> 'GET',
		'url'							=> "$URL_BASE/articles/$video_id/videos/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'404'							=> {
				'error'						=> '404 Not Found',
			}
		},
	}
}

sub write_config {
	$config->write($config_file_path, 'utf8') or die "Error writing config " . $config->errstr();
}

sub cook_auth {
	my $user_id = shift;
	my $device_token = shift;

	'Basic ' . encode_base64 "$user_id:$device_token", '';
}

sub call_api {
	my $api_request = shift;

	# TODO: Try implementing via $user_agent->default_headers
	my $headers = HTTP::Headers->new(
		'X-User-Agent'									=> "$DEVICE_NAME; API_CONSUMER_KEY=$API_CONSUMER_KEY",
		'Accept'												=> "application/tvrain.api.$API_VERSION+json",
		'Content-Type'									=> 'application/x-www-form-urlencoded',
	);

	my $encoded_params = $cgi_utils->url_encode_vars($api_request->{'post_params'}, '&') if keys %{$api_request->{'post_params'}};
	$api_request->{'extra_headers'}->{'Content-Length'} = length $encoded_params if $encoded_params;

	foreach my $key (keys %{$api_request->{'extra_headers'}}) {
		$headers->push_header($key => $api_request->{'extra_headers'}->{$key});
	}

	$headers->push_header('Authorization' => $config->{_}->{'auth'}) if defined $config->{_}->{'auth'};

	my $request = HTTP::Request->new(
		$api_request->{'method'},
		$api_request->{'url'},
		$headers,
		$encoded_params
	);

	debug 'request', $request->as_string if $options->{'verbose'};

	my $response = $user_agent->request($request);

	if ($response->is_success) {
		debug 'response', $response->content if $options->{'verbose'};

		return decode_json $response->content;
	} else {
		if (defined $api_request->{'error_overrides'}->{$response->code}) {
			debug 'response', 'Executing error override for HTTP return code ' . $response->code if $options->{'verbose'};

			return $api_request->{'error_overrides'}->{$response->code};
		} else {
			die "Error processing “$api_request->{'name'}” API call: " . $response->status_line;
		}
	}
}


### Read command line options

GetOptions ($options, 'verbose|v') or die "Invalid options";
# TODO: print usage if options are invalid

$video_id = pop or die "No video ID or URL";
# TODO: print usage if no vido id

# Check and fix video ID
if ($video_id =~ /^\d+$/) {
	# Good 
} elsif ($video_id =~ /tvrain\.ru.*-(\d+)\/?$/) {
	$video_id = $1;
} else {
	die "Invalid vido ID or URL";
	# TODO: Print proper error message and usage
}

debug 'video id', $video_id if $options->{'verbose'};


### Read system config and init it if needed

$config = Config::Tiny->read($config_file_path, 'utf8');

unless (defined $config) {
	print "Empty / invalid config file → recreating\n";

	$config = Config::Tiny->new;
	$config->{_}->{'device_uid'} = &cook_device_uid;
	&write_config;

	print "New device uid created\n";
}


### Login or else link

unless (defined $config->{_}->{'auth'}) {
	print "Absent / invalid authentication → linking to account\n";
	
	my $startlinking_response = call_api &cook_startlinking_request;

	print "Code for linking: $startlinking_response->{'code'}\n\n";
	print "Q: What shall I do now?\n";
	print "A: 1. Open http://tvrain.ru/profile/ in brwoser\n";
	print "   2. Log into your account\n";
	print "   3. Browse to Profile → Devices\n";
	print "   4. Enter the linking code and perss Link\n";
	print "   5. Wait until the get_tvrain resumes\n\n";

	my $link_request = cook_link_request $startlinking_response->{'oid'};

	print "Trying to link…\n";
	my $link_response;

	do {
		# TODO: Add some kind of sandwatch
		sleep $LINK_POLL_TIMEOUT_SEC;

		$link_response = call_api $link_request;
	} until (defined $link_response->{'user_id'});

	print "Link established\n";

	$config->{_}->{'user_id'} = $link_response->{'user_id'};
	$config->{_}->{'auth'} = cook_auth $link_response->{'user_id'}, $link_response->{'device_token'};

	&write_config;
}


### Get user profile

$me = call_api &cook_me_request;
# TODO: Handle authentication error
print "Login Ok, subscription active for $me->{'vip'} more days\n";


### Get video info

my $videos_response = call_api cook_videos_request $video_id;

die "Video not found" if defined $videos_response->{'error'};
# TODO: Properly inform user about bad video ID
