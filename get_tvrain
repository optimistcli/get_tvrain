#!/usr/bin/perl

###
###	⛈	optimistiCli: TVRain.ru command line client that gives legitimate paying users command line access to the video archive.
###

use utf8;
use strict;

### TODOs:
###  1. Use ffmpeg or avconv instaed if mkvmerge, whatever is present in the system
###  2. Add config and command line options to set merger
###  3. Gracefully check for perl dependencies, probably auto-install them or create Makefile.PL
###  4. Add config option for output dir
###  5. Add command to list videos
###  6. Check for wget presence and revert to playlist if it is absent
###  7. Check for the merger presence and revert to save if it is absent
###  8. Switch to curl
###  9. Command to download latest full program by name
### 10. Use OS-ondepenadant path handling

our $usage = 'Usage:
  get_tvrain [-h|--long-help] [-v] [-F] [-S] [-c <merge|save|pls>] 
             [-q <hd|sd|lo>] [-d <output dir>] [-o <output file name>] 
             [-t <temp dir>] [-i] [-C <config file>] 
             <Video ID | Page with video URL> 

TVRain.ru show archive command line client. Legitimate paying users only! 

To download a show in current directory run: 
  get_tvrain http://tvrain.ru/teleshow/reportazh/the_rain_is_falling-123456/

To get detailed options description run: 
  get_tvrain --long-help
';

our $long_help = $usage . '
Options:
  -h Show usage and exit
  -v Verbose output, prints a lot of debugging stuff to STDERR
  -F Force first run, resets all options, see below
  -S Simulate, do not actualy download anything
  -c Command, instructs get_tvrain what to do:
       merge - downloads all parts of the video and merges them into one 
               matroska file, requires temp directory for downloaded parts, 
               this is the default command
       save  - saves each part of the video as is
       pls   - does not download any video, saves a playlist with video URLs
  -q Video quality selector, available options are:
       hd - high definition aka 720p (default)
       sd - standard definition aka 480p
       lo - low bitrate aka 360p
  -d Write output file(s) to the specified directory, defaults to current 
     directory
  -o Set output file(s) name, if omitted the article / feature name is used 
     to compose the file name(s); overrides -d and -i
  -t Use specified directory to temporarily store downloaded video parts for 
     the "merge" command, if omitted looks up temp_dir in the configuration 
     file, which defaults to the current directory
  -i Use video ID for the file(s) name
  -C Use specified configuration file instead of the default one

Examples:
  Download a show by URL, if video consists of several parts merge them 
  together. Use /tmp to store temporary files.
  get_tvrain -t /tmp http://tvrain.ru/teleshow/reportazh/falling_rain-123456/

  Download a show known by its ID to the Desktop. Select low bitrate to 
  preserve the bandwidth. If there are several video files save them 
  separately. Name files using show ID.
  get_tvrain -d ~/Desktop -q lo -c save -i 123456

  Create a custom-named playlist of the standard definition videos. If a 
  playlist by the same name already exists overwrite it.
  get_tvrain -q sd -o /mnt/autoplay/tvrain.pls -c pls -y 123456

Configuration file:
  The configuration file is .get_tvrain.conf in your home directory, This file 
  is created automatically during the first run. Use -C option to run with 
  alternative configuration file. File format is name=value, no whitespaces 
  around the "=", no comments after the value are allowed. Encoding is UTF-8.
  Noteworthy options:
    device_uid
      Client-side hardware unique identifier / serial number. In fact this 
      value is randomly generated during the first run.
    auth
      Authentication key. This value is obtained from the server when the 
      client is linked to TVRain.ru user account as a part of the first run 
      routine.
    temp_dir
      The directory to temporarily store downloaded video parts for the 
      "merge" command. Please make sure the directory is on a reasonably fast 
      storage device (ie the use of thumb drives and flash cards is 
      discouraged) and that it has enough free space (4Gb would do). If not 
      set the current directory or the value passed with the -t option is 
      used.

First run:
  When run for the first time the "first run routine" is invoked to configure 
  the application. It does as follows:
    1. configuration file is created
    2. unique identifier is randomly generated
    3. client is linked to the TVRain.ru user account
    4. temporary directory is set
  To clear all the settings the first run routine can be re-run manually 
  by specifying the -F option or just by deleting the configuration file.

Linking:
  In order to gain access to the TVRain.ru show archive the client software 
  should be "linked" to an active paid user account. Linking happens during 
  the first run and requires internet access and user interaction.

';

our $linking_hint = 'Q What to do next?
A 1. Open http://tvrain.ru/profile/ in a brwoser
  2. Log into an account
  3. Browse to "Profile" → "Devices"
  4. Enter the linking code (see above) and perss "Link"
  5. Wait until get_tvrain resumes\n

';

our $relink_hint = '

You might want to re-link the client by specifying the -F option.
For more details please run:
get_tvran --long-help
';


use open IO  => ":encoding(utf8)";
binmode STDOUT, ":utf8";
binmode STDERR, ":utf8";

use Env qw(HOME);
use Config::Tiny;
use HTTP::Headers;
use HTTP::Request;
use CGI::Utils;
use LWP::UserAgent;
use JSON;
use MIME::Base64 qw(encode_base64);
use Getopt::Long qw(:config no_ignore_case require_order bundling);
use IO::Scalar;
use Cwd qw(realpath);
use IPC::Run3;


### Constants

our $CONFIG_FILE_NAME = '.get_tvrain.conf';
our $DEVICE_NAME = 'NothingBut Client'; #'optimistiCli';
our $URL_BASE = 'https://api.tvrain.ru/api_v2';
our $API_CONSUMER_KEY = 'a908545f-80af-4f99-8dac-fb012cec';
our $API_VERSION = '2.13';
our $LINK_POLL_TIMEOUT_SEC=15;
our $COMMAND_MERGE = 'merge';
our $COMMAND_SAVE = 'save';
our $COMMAND_PLAYLIST = 'pls';
our $QUALITY_HD = 'hd';
our $QUALITY_SD = 'sd';
our $QUALITY_LO = 'lo';
# TODO: Implement proper file name length check
our $MAXLENGTH = 48; # 255; 
our @WGET_ERRORS = (
	'No problems occurred',
	'Generic error code',
	'Parse error—for instance, when parsing command-line options, the ".wgetrc" or ".netrc"',
	'File I/O error',
	'Network failure',
	'SSL verification failure',
	'Username/password authentication failure',
	'Protocol errors',
	'Server issued an error response',
);


### Globals

our $options;	# Command line options
our $config;	# Config file values
our $session;	# Session-wide values

# TODO: Integrate following into session
our $cgi_utils;
our $user_agent;
our $video_id;

### Init

$cgi_utils = CGI::Utils->new;
$user_agent = LWP::UserAgent->new;

# Set options defaults
$options = {
	'help'				=> 0,
	'long_help'		=> 0,
	'verbose'			=> 0,
	'simulate'		=> 0,
	'first_run'		=> 0,
	'command'			=> $COMMAND_MERGE,
	'quality'			=> $QUALITY_HD,
	'output_dir'	=> undef,
	'output_file'	=> undef,
	'temp_dir'		=> undef,
	'id'					=> 0,
	'yes-all'			=> 0,
	'config'			=> undef,
};

### Functions

sub dumpit;

sub dumpit {
	my $workload = shift;
	my $name = shift;
	my $depth = shift;

	$depth ||= 0;

	my $buffer = '';

	my $type = ref($workload);

	if ($type eq 'ARRAY') {
		$buffer .= '  ' x $depth;
		$buffer .= $name . ' → ' if defined $name;
		$buffer .= "[\n";

		for (my $i = 0 ; $i < scalar @$workload; $i++) {
			$buffer .= dumpit $workload->[$i], $i, $depth + 1;
		}

		$buffer .= '  ' x $depth;
		$buffer .= "]\n";
	} elsif ($type eq 'HASH') {
		$buffer .= '  ' x $depth;
		$buffer .= $name . ' → ' if defined $name;
		$buffer .= "{\n";

		foreach my $key (sort keys %$workload) {
			$buffer .= dumpit $workload->{$key}, $key, $depth + 1;
		}

		$buffer .= '  ' x $depth;
		$buffer .= "}\n";
	} else {
		$buffer .= '  ' x $depth;
		$buffer .= $name . ' → ' if defined $name;
		$buffer .= "$workload\n";
	}

	return $buffer;
}

# TODO: Implement 2-level verbosity with no operational output on base level.
sub debug {
	my $title = shift;
	my $text = shift;
	
	$title = uc $title;
	print STDERR "============ $title START ============\n$text\n============= $title END =============\n\n";
}

sub brag_and_exit {
	my $err_message = shift;
	my $exit_code = shift;

	if ($err_message) {
		chomp $err_message;
		$err_message =~ s/^/  /gms;
		$err_message = "Error:\n$err_message\n\n";
		$exit_code = 1 unless $exit_code;
	}

	print $err_message, $usage, "\n";
	exit $exit_code;
}

# Creates an empty file and immediately deletes it
sub get_file_creation_error {
	my $file_path = shift;
	my $description = shift;

	return "$description already exists '$file_path" if -e $file_path;

	open FH, "> $file_path" or return "$description can not be written to '$file_path', $!";
	close FH;

	unlink $file_path or die "Failed to delete touched file '$file_path'";

	return undef;
}

sub get_dir_wrieable_error {
	my $dir_path = shift;
	my $description = shift;

	return "$description '$dir_path' does not exist" unless -e $dir_path;

	return "$description '$dir_path' is not a directory" unless -d $dir_path;

	return "$description '$dir_path' can not be written to" unless -w $dir_path;

	undef;
}

sub check_if_dir_is_wrieable {
	my $dir_path = shift;
	my $description = shift;

	return unless defined $dir_path;

	my $dir_wrieable_error = get_dir_wrieable_error $dir_path, $description;

	brag_and_exit $dir_wrieable_error if defined $dir_wrieable_error;

	$dir_path;
}

sub check_option_command {
	# Command should be set, otherwise there is an error
	$_ = $options->{'command'};

	$options->{'command'} = 
		/^m|merge|mkv|join|matroska$/i ? $COMMAND_MERGE :
		/^s|save|download|dl|asis|mp4|dump$/i ? $COMMAND_SAVE :
		/^p|pls|playlist|pls|play.list|m3u|m3u8$/i ? $COMMAND_PLAYLIST :
		brag_and_exit "Unknown command $_";

	debug 'command', $options->{'command'} if $options->{'verbose'};
}

sub check_option_quality {
	# Quality should be set, otherwise there is an error
	$_ = $options->{'quality'};

	$options->{'quality'} = 
		/^h|hd|hq|high|hi|720|720p$/i ? $QUALITY_HD :
		/^s|sd|sq|stand.*|std|480|480p$/i ? $QUALITY_SD :
		/^l|lo|ld|lq|lo|low|360|360p$/i ? $QUALITY_LO :
		brag_and_exit "Unknown quality $_";

	debug 'quality', $options->{'quality'} if $options->{'verbose'};
}

sub check_option_output_dir {
	return unless defined $options->{'output_dir'};

	$options->{'output_dir'} = check_if_dir_is_wrieable $options->{'output_dir'}, 'Output directory';

	debug 'output dir', $options->{'output_dir'} if $options->{'verbose'};
}

sub check_if_file_is_writeable {
	my $file_path = shift;
	my $description = shift;

	return unless defined $file_path;

	if (-e $file_path) {
		# File exist: check if it is a proper file and if it can be overwritten

		brag_and_exit "$description is not a file '$file_path'" unless -f $file_path;

		# TODO: Simlinks get through the -f above. Decide if they need some special tratment.

		brag_and_exit "$description can not be overwritten '$file_path'" unless -w $file_path;
	} else {
		# File does not exist: check if it can be created and written to

		my $file_creation_error = get_file_creation_error $file_path, $description;
		brag_and_exit $file_creation_error if defined $file_creation_error;
	}

	$file_path;
}

sub check_option_output_file {
	return unless defined $options->{'output_file'};

	$options->{'output_file'} = check_if_file_is_writeable $options->{'output_file'}, 'Output file';

	debug 'output file', $options->{'output_file'} if $options->{'verbose'};
}

sub check_option_temp_dir {
	return unless defined $options->{'temp_dir'};

	$options->{'temp_dir'} = check_if_dir_is_wrieable $options->{'temp_dir'}, 'Temporary directory';

	debug 'temp dir', $options->{'temp_dir'} if $options->{'verbose'};
}

sub check_option_config {
	return unless defined $options->{'config'};

	if (-e $options->{'config'}) {
		brag_and_exit "Config file '$options->{'config'}' can not be written to" unless -w $options->{'config'};

		# Avoid accidental damage: accept config file only if the file is a proper config file or if it is an empty file
		brag_and_exit "Cowardly refusing to use non-config file '$options->{'config'}'" 
			unless defined Config::Tiny->read($options->{'config'}, 'utf8') 
				|| (stat($options->{'config'}))[7] == 0;
	} else {
		my $file_creation_error = get_file_creation_error $options->{'config'}, 'Config file';
		brag_and_exit $file_creation_error if defined $file_creation_error;
	}

	debug 'config', $options->{'config'} if $options->{'verbose'};
}

sub cook_rand_xxxx {
	sprintf "%04X", int rand 0x10000;
}

sub cook_device_uid {
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx . '-' . 
	&cook_rand_xxxx;
}

sub cook_quickauth_request {
	{
		'name'					=> 'quickauth',
		'method'				=> 'POST',
		'url'						=> "$URL_BASE/user/quickauth/",
		'post_params'		=> {
			'device_uid'		=> $config->{_}->{'device_uid'},
		},
		'extra_headers'	=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_startlinking_request {
	{
		'name'					=> 'startlinking',
		'method'				=> 'POST',
		'url'						=> "$URL_BASE/user/startlinking/",
		'post_params'		=> {
		},
		'extra_headers'	=> {
		},
		'error_overrides'	=> {
		},
	}
}

sub cook_link_request {
	my $oid = shift;

	{
		'name'						=> 'link',
		'method'					=> 'POST',
		'url'							=> "$URL_BASE/user/link/",
		'post_params'			=> {
			'device_uid'			=> $config->{_}->{'device_uid'},
			'oid'							=> $oid,
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'401'							=> {
				'error'						=> '401 Unauthorized',
			}
		},
	}
}

sub cook_me_request {
	{
		'name'						=> 'me',
		'method'					=> 'GET',
		'url'							=> "$URL_BASE/user/me/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'403'							=> {
				'error'						=> '403 Forbidden',
			}
		},
	}
}

sub cook_videos_request {
	my $video_id = shift;

	{
		'name'						=> 'videos',
		'method'					=> 'GET',
		'url'							=> "$URL_BASE/articles/$video_id/videos/",
		'post_params'			=> {
		},
		'extra_headers'		=> {
		},
		'error_overrides'	=> {
			'404'							=> [{
				'error'						=> '404 Not Found',
			}]
		},
	}
}

sub write_config {
	$config->write($session->{'config_file_path'}, 'utf8') or die "Error writing config " . $config->errstr();
}

sub cook_auth {
	my $user_id = shift;
	my $device_token = shift;

	'Basic ' . encode_base64 "$user_id:$device_token", '';
}

sub call_api {
	my $api_request = shift;

	# TODO: Try implementing via $user_agent->default_headers
	my $headers = HTTP::Headers->new(
		'X-User-Agent'									=> "$DEVICE_NAME; API_CONSUMER_KEY=$API_CONSUMER_KEY",
		'Accept'												=> "application/tvrain.api.$API_VERSION+json",
		'Content-Type'									=> 'application/x-www-form-urlencoded',
	);

	my $encoded_params = $cgi_utils->url_encode_vars($api_request->{'post_params'}, '&') if keys %{$api_request->{'post_params'}};
	$api_request->{'extra_headers'}->{'Content-Length'} = length $encoded_params if $encoded_params;

	foreach my $key (keys %{$api_request->{'extra_headers'}}) {
		$headers->push_header($key => $api_request->{'extra_headers'}->{$key});
	}

	$headers->push_header('Authorization' => $config->{_}->{'auth'}) if defined $config->{_}->{'auth'};

	my $request = HTTP::Request->new(
		$api_request->{'method'},
		$api_request->{'url'},
		$headers,
		$encoded_params
	);

	debug 'request', $request->as_string if $options->{'verbose'};

	my $response = $user_agent->request($request);

	if ($response->is_success) {
		debug 'response', $response->content if $options->{'verbose'};

		return decode_json $response->content;
	} else {
		if (defined $api_request->{'error_overrides'}->{$response->code}) {
			debug 'response', 'Executing error override for HTTP return code ' . $response->code if $options->{'verbose'};

			return $api_request->{'error_overrides'}->{$response->code};
		} else {
			die "Error processing “$api_request->{'name'}” API call: " . $response->status_line;
		}
	}
}

sub read_command_line_options {
	my $error_message;
	my $error = tie *STDERR, 'IO::Scalar', \$error_message;

	my $all_went_well = GetOptions ($options, 
		'help|h',
		'long_help|long-help',
		'verbose|v',
		'simulate|S',
		'first_run|first-run|F',
		'command|c=s',
		'quality|q=s',
		'output_dir|output-dir|d=s',
		'output_file|output-file|o=s',
		'temp_dir|temp-dir|t=s',
		'id|i',
		'yes-all|y',
		'config|C=s',
	);

	undef $error;
	untie *STDERR;

	brag_and_exit $error_message unless $all_went_well;
}

sub deal_with_help_requests {
	print $long_help and exit if $options->{'long_help'};

	&brag_and_exit if $options->{'help'};
}

sub interpret_command_line_options {
	&check_option_command;
	&check_option_quality;
	&check_option_output_dir;
	&check_option_output_file;
	&check_option_temp_dir;
	&check_option_config;
}

sub get_video_id {
	brag_and_exit 'No video ID or URL' unless scalar @ARGV;

	$_ = pop @ARGV;

	if (/^\d+$/) {
		$session->{'video_id'} = $_;
	} elsif (/tvrain\.ru.*-(\d+)\/?$/) {
		$session->{'video_id'} = $1;
	} else {
		brag_and_exit "Invalid video ID or URL";
	}

	debug 'video id', $session->{'video_id'} if $options->{'verbose'};
}

sub set_config_file_path {
	$session->{'config_file_path'} = 
		defined $options->{'config'} ? $options->{'config'} :
		"$HOME/$CONFIG_FILE_NAME";

	debug 'config file path', $session->{'config_file_path'} if $options->{'verbose'};
}

sub create_clean_config {
	$config = Config::Tiny->new;
	$config->{_}->{'device_uid'} = &cook_device_uid;

	&write_config;

	print "New device uid created\n";
}

sub read_config {
	if ($options->{'first_run'}) {
		print "Resetting config file per user request\n";
		&create_clean_config;
	} else {
		$config = Config::Tiny->read($session->{'config_file_path'}, 'utf8');

		unless (defined $config && defined $config->{_}->{'device_uid'}) {
			print "Empty / invalid config file → recreating\n";
			&create_clean_config;
		}
	}

	debug 'device uid', $config->{_}->{'device_uid'} if $options->{'verbose'};
}

sub save_default_temp_dir {
	my $temp_dir = shift;

	$config->{_}->{'temp_dir'} = $temp_dir;

	print "Default temporary dir is set to '$temp_dir'\n";

	&write_config;
}

sub ask_user_for_deafult_temp_dir {
	my $dir_wrieable_error;
	my $temp_dir;

	do {
		print "Please set the default temporary directory.\nJust press 'Enter' to each time use current directory.\n:";

		$temp_dir = <STDIN>;
		chomp $temp_dir;
		$temp_dir =~ s/^\s+//;
		$temp_dir =~ s/\s+$//;

		if ($temp_dir eq '') {
			$temp_dir = '.'
		} elsif ($temp_dir =~ /^\.{1,2}(?:\/.*)?$/) {
			$temp_dir = realpath $temp_dir;
		} elsif ($temp_dir =~ /^\~(\/.*)?$/) {
			$temp_dir = "${HOME}$1";
		}

		$dir_wrieable_error = get_dir_wrieable_error $temp_dir, 'Default temporary directory';

		print $dir_wrieable_error, "\n\n" if defined $dir_wrieable_error;
	} while (defined $dir_wrieable_error);

	return $temp_dir;
}

sub decide_on_temp_dir {
	if (defined $config->{_}->{'temp_dir'}) {
		if (defined $options->{'temp_dir'}) {
			# Use options, no checking needed
			$session->{'temp_dir'} = $options->{'temp_dir'};
		} else {
			# Check and use config
			$session->{'temp_dir'} = check_if_dir_is_wrieable $config->{_}->{'temp_dir'}, 'Default temporary directory';
		}
	} else {
		if (defined $options->{'temp_dir'}) {
			# Use options and write it to config
			save_default_temp_dir $options->{'temp_dir'};

			$session->{'temp_dir'} = $options->{'temp_dir'};
		} else {
			# It's first run: ask user, check, write to config and use
			save_default_temp_dir &ask_user_for_deafult_temp_dir;

			$session->{'temp_dir'} = $config->{_}->{'temp_dir'};
		}
	}

	check_if_dir_is_wrieable $options->{'temp_dir'}, 'Temporary directory';
}

sub link_if_not_linked {
	return if defined $config->{_}->{'auth'};

	print "Absent / invalid authentication → linking to account\n";
	
	my $startlinking_response = call_api &cook_startlinking_request;

	print "Linking code:\n  $startlinking_response->{'code'}\n\n$linking_hint";

	my $link_request = cook_link_request $startlinking_response->{'oid'};

	print "Trying to link…\n";
	my $link_response;

	do {
		# TODO: Add some kind of sandwatch
		sleep $LINK_POLL_TIMEOUT_SEC;

		$link_response = call_api $link_request;
	} until (defined $link_response->{'user_id'});

	print "Link established\n";

	$config->{_}->{'auth'} = cook_auth $link_response->{'user_id'}, $link_response->{'device_token'};

	&write_config;
}

sub get_me_to_check_auth {
	my $me_response = call_api &cook_me_request;

	brag_and_exit "Authentication failure${relink_hint}" if defined $me_response->{'error'};

	$session->{'me'} = $me_response;

	die "Malformed 'me' response" unless defined $session->{'me'}->{'vip'};

	brag_and_exit "Subscription expired :-(\nPlease visit TVRain.ru and pay them, then come back." if $session->{'me'}->{'vip'} < 0;

	print "Login Ok, subscription active for $session->{'me'}->{'vip'} more days\n";
}

sub get_videos {
	my $videos_response = call_api cook_videos_request $session->{'video_id'};

	brag_and_exit "Video not found\nPlease check Video ID / URL" if defined $videos_response->[0]->{'error'};

	$session->{'videos'} = $videos_response;

	debug 'videos', dumpit $session->{'videos'} if $options->{'verbose'};
}

sub get_common_name {
	my $common;

	for (my $i = 0; $i < scalar @{$session->{'videos'}}; $i++) {
		$_ = $session->{'videos'}->[$i]->{'name'};

		# If the name is not prceded with smth like 1/3 there is no common name
		return undef unless /^\d+\W\d+\s+(.*)$/;

		$common ||= $1;

		# If the part of the name that follows numbers is differernt from fule to file then there is no common name
		return undef unless $1 eq $common;
	}

	return $common;
}

sub cook_extension {
	return '.mkv' if $options->{'command'} eq $COMMAND_MERGE;

	return '.mp4' if $options->{'command'} eq $COMMAND_SAVE;

	return '.m3u8' if $options->{'command'} eq $COMMAND_PLAYLIST;

	die 'Unknown command';
}

sub fit_file_name_length {
	$_ = shift;

	return $_ if length $_ <= $MAXLENGTH;

	s/(\.\S+?)$//;
	my $ext = $1;

	substr($_, 0,$MAXLENGTH - length $ext - 1) . '…' . $ext;
}

sub cook_file_name {
	local $_;

	$_ = $session->{'video_id'} if $config->{_}->{'id'};

	$_ ||= &get_common_name;

	$_ ||= $session->{'videos'}->[0]->{'name'};

	die 'Can not cook file name' unless $_;

	s/^\s+//;
	s/\s+$//;
	s/\s*:+\s*/ - /g;
	s/[:#\\\/\*]+/./g;
	s/[\{\<]/[/g;
	s/[\}\>]/[]/g;

	$_ .= &cook_extension;

	fit_file_name_length $_;
}

sub cook_output_dir {
	return $options->{'output_dir'} if defined $options->{'output_dir'};

	return check_if_dir_is_wrieable '.', 'Current directory';
}

sub decide_on_output_path {
	$session->{'output_path'} = defined $options->{'output_file'}
		? $options->{'output_file'}
		: check_if_file_is_writeable &cook_output_dir . '/' . &cook_file_name, 'Output path';

	debug 'output path', $session->{'output_path'} if $options->{'verbose'};
}

sub get_quality_url_key {
	my $quality = shift;

	return '720p' if $quality eq $QUALITY_HD;
	return '480p' if $quality eq $QUALITY_SD;
	return '360p' if $quality eq $QUALITY_LO;

	die "Unexpected quality";
}

sub clean_string_for_backticks {
	$_ = shift;
	s/'/'\\''/g;
	$_;
}

sub get_wget_error {
	my $wget_exit_code = shift;

	return $WGET_ERRORS[$wget_exit_code] if defined $WGET_ERRORS[$wget_exit_code];

	return 'Unrecognized error';
}

sub download_url_to_path {
	my $url = shift;
	my $output_path = shift;

	my $wget_call = [
		'wget',
		'-O',
		$output_path,
		$url,
	];

	debug 'wget call', join "\n", @$wget_call if $options->{'verbose'};

	run3 $wget_call unless $options->{'simulate'};
	my $wget_exit_code = $?>> 8;
	die "Wget failed: " . get_wget_error $wget_exit_code if $wget_exit_code;
}

sub cook_temp_video_path {
	my $url = shift;

	$url =~ /\/([^\/]*)$/;

	$session->{'temp_dir'} . '/tvrain-' . &cook_rand_xxxx . '-' . $1;
}

sub download_temp_video {
	my $video = $session->{'videos'}->[shift];

	my $url = $video->{'mp4'}->{get_quality_url_key $options->{'quality'}};
	my $temp_video_path = cook_temp_video_path $url;

	download_url_to_path $url, $temp_video_path;

	$temp_video_path;
}

sub download_temp_videos {
	my @temp_videos;

	for (my $i = 0 ; $i < scalar @{$session->{'videos'}}; $i++) {
		push @temp_videos, download_temp_video $i;
	}

	$session->{'temp_videos'} = \@temp_videos;
}

sub merge_temp_videos {
	my $mkvmerge_call = ['mkvmerge'];

	push @$mkvmerge_call, '-o', $session->{'output_path'};

	my $put_a_plus = 0;
	for (my $i = 0 ; $i < scalar @{$session->{'temp_videos'}}; $i++) {
		my $buffer = $put_a_plus
			? '+'
			: '';

		$buffer .= $session->{'temp_videos'}->[$i];

		push @$mkvmerge_call, $buffer;

		$put_a_plus = 1;
	}

	debug 'mkvmerge call', join "\n", @$mkvmerge_call if $options->{'verbose'};

	run3 $mkvmerge_call unless $options->{'simulate'};
	my $mkvmerge_exit_code = $?>> 8;
	die "mkvmerge failed" if $mkvmerge_exit_code > 1;
}

sub delete_temp_videos {
	return if $options->{'simulate'};

	for (my $i = 0 ; $i < scalar @{$session->{'temp_videos'}}; $i++) {
		unlink $session->{'temp_videos'}->[$i] or warn "Can not delete temporary video $session->{'temp_videos'}->[$i]";
	}
}

sub merge_it {
	&download_temp_videos;
	&merge_temp_videos;
	&delete_temp_videos;

	print "$session->{'output_path'}\n";
}

sub download_video_to_save {
	my $number = shift;

	my $video = $session->{'videos'}->[$number];

	my $url = $video->{'mp4'}->{get_quality_url_key $options->{'quality'}};

	$session->{'output_path'} =~ /^(.*\/)([^\/]+)$/;
	my $save_to_path = sprintf '%s%02i-%s', $1, $number + 1, $2;

	download_url_to_path $url, $save_to_path;
}

sub save_several_videos {
	for (my $i = 0 ; $i < scalar @{$session->{'videos'}}; $i++) {
		download_video_to_save $i;
	}
}

sub save_one_video {
	my $video = $session->{'videos'}->[0];

	my $url = $video->{'mp4'}->{get_quality_url_key $options->{'quality'}};

	download_url_to_path $url, $session->{'output_path'};
}

sub save_it {
	scalar @{$session->{'videos'}} == 1
		? &save_one_video
		: &save_several_videos;
}

sub cook_m3u_header {
	"#EXTM3U\n\n";
}

sub cook_m3u_item {
	my $video = $session->{'videos'}->[shift];

	sprintf "#EXTINF:%.2f, До///дь - %s\n%s\n\n",
		$video->{'duration'} / 1000,
		$video->{'name'},
		$video->{'mp4'}->{get_quality_url_key $options->{'quality'}};
}

sub cook_m3u_footer {
	'';
}

sub playlist_it {
	my $buffer = '';

	$buffer .= &cook_m3u_header;

	for (my $i = 0 ; $i < scalar @{$session->{'videos'}}; $i++) {
		$buffer .= cook_m3u_item $i;
	}

	$buffer .= &cook_m3u_footer;

	debug 'playlist', $buffer if $options->{'verbose'};

	open PLS, "> $session->{'output_path'}" or die "Can not open output file to write $session->{'output_path'}";
	print PLS $buffer or die "Can not write to output file $session->{'output_path'}";
	close PLS;
}

sub main {
	&read_command_line_options;
	&deal_with_help_requests;
	&interpret_command_line_options;
	&get_video_id;
	&set_config_file_path;
	&read_config;
	&decide_on_temp_dir;
	&link_if_not_linked;
	&get_me_to_check_auth;
	&get_videos;
	&decide_on_output_path;

	&merge_it if $options->{'command'} eq $COMMAND_MERGE;

	&save_it if $options->{'command'} eq $COMMAND_SAVE;

	&playlist_it if $options->{'command'} eq $COMMAND_PLAYLIST;

}


### Main

&main;
